\label{sec:protocol}
We are now ready to present our protocol. The main idea it exploits is the concept of \emph{configuration graph} which we will present here only informally\footnote{The interested reader may consult an introductory textbook on computational complexity such as \cite{arora2009computational}.}. A configuration of a Turing Machine is a complete description of the current state of the computation: the state of $M$, the position of its heads, the non-blank values on its tapes.  Let $M$ be a (possibly nondeterministic) TM and $x$ a string.
The set of nodes in the configuration graph $G_{M,x}$  of $M$ when executed on input $x$ is the set of configurations of $M$ with $x$ on its $M$'s input tape. There is an arc from configuration $C_i$ to configuration $C_j$ if and only if any of the transition functions of $M$ produces $C_j$ when given in input the information in configuration $C_i$.

We can reduce the problem of whether $M$ accepts an input $x$ to a reachability problem in its configuration graph: in fact $M(x) = 1$ if and only if there exists a path from a starting configuration to an accepting one. If $M$ terminates in polynomial time then such a path must be of length at most polynomial.

The protocol presented below is a more general version of the one used in \cite{cg15} and very simple in structure. It consists of a "chasing game" between the verifier and the prover, where the prover "commits" at each step to an intermediate configuration. If the prover is cheating the configuration may or may not follow from the initial configuration or lead to the final accepting configuration. At each step and after $P$ communicates the intermediate configuration $C'$ the verifier then randomly chooses whether to continue invoking the protocol on the left or the right of $C'$. The protocol terminates when $V$ ends up on two previously declared adjacent configurations that he can check.  Intuitively, the protocol works since, if $x$ is not in the language, for any possible sequence of the prover's messages, there is at least one choice of random coins that allows $V$ to detect it; the space of such choices is polynomial in size.

We assume that $V$ has oracle access to the input $x$.
%\clearpage
\noindent What follows is a formal description of the protocol.
\begin{framed}
\begin{enumerate}
    \item $P$ sends to $V$:
    \begin{itemize}
    \item $C_{N}$, the final accepting configuration (the starting configuration, $C_1$, is known to the verifier);
    \item $N$, the number of steps between the two configurations. % Does it need to? sort of yes. What if the guy lies. It should be discussed possibly.
    \end{itemize}
    \item Then $V$ invokes the procedure $\PathCheck(N, C_{1}, C_{N})$.
\end{enumerate}
\end{framed}

\medskip
\noindent The procedure $\PathCheck(m, C_l, C_r)$ is defined for $1 \leq m \leq N$ as 
follows:
\begin{framed}
\begin{itemize}
    \item If $m > 1$, then:
    \begin{enumerate}
        \item $P$ sends intermediate configurations $C_{p}$ and $C_q$ (which may coincide) where $p = \lfloor \frac{l+m-1}{2} \rfloor$  and 
        $q = \lceil \frac{l+m-1}{2} \rceil$. % (m == r-l+1)
        \item If $p \neq q$, $V$ checks whether there is a transition leading from configuration $C_p$ to configuration $C_q$. If yes, $V$ accepts; otherwise $V$ halts and rejects.
	\item $V$ generates a random bit $b \in_R \bit$
        \item If  $b = 0$ then the protocol continues invoking $\PathCheck(\lfloor \frac{m}{2} \rfloor, C_l, C_p)$; If $b = 1$ the protocol continues invoking $\PathCheck(\lfloor \frac{m}{2} \rfloor, C_q, C_r)$
    \end{enumerate}
    \item If $m = 1$, then $V$ checks whether there is a transition leading from configuration $C_l$ to configuration $C_r$. If $l=1$, $V$ checks that $C_l$ is indeed the initial configuration $C_1$. If $r=N$, $V$ checks that $C_r$ is indeed the final configuration sent by $P$ at the beginning. If yes, $V$ accepts; otherwise $V$ rejects.
\end{itemize}
\end{framed}

\medskip

\begin{theorem}
\label{thm:main}
$\NTISP[\poly(n), S(n)] \subseteq \DRMA[O(\log n), O(S(n)\log n), O(S(n)\log n)]$
\end{theorem}
\begin{proof}
% Efficiency
Let us consider the efficiency of the protocol above.
It requires $O(\log n)$ rounds.
Since the computation is in $\NTISP[\poly(n), S(n)]$, the configurations $P$ sends to $V$ at each round have size $O(S(n) \log n)$.
The verifier only needs to read the configurations and, at the last round, check the existence of a transition leading from $C_l$ to $C_r$. $V$ can carry out the latter test in $O(S(n) \log n)$ time.

% Soundness
Let us now prove that this is a rational proof with noticeable reward gap.
%by showing the protocol satisfies the hypothesis of Lemma \ref{lemma:ip2rp}. 
Observe that the protool has perfect completeness. 
Let us now prove that the soundness is at most $1 - 2^{-\log N} = 1 - \frac{1}{O(\poly(n))}$.
We aim at proving that, if there is no path between the configurations $C_1$ and $C_N$ then $V$ rejects with probability at least $2^{-\log N}$.
Assume, for sake of simplicity, that $N = 2^k$ for some $k$. We will proceed by induction on $k$. If $k=1$, $P$ provides the only intermediate configuration $C'$ between $C_1$ and $C_N$. At this point $V$ flips a coin and the protocol will terminate after testing whether there exists a transition between $C_1$ and $C'$ or between $C'$ and $C_N$. Since we assume the input is not in the language, there exists at most one of such transitions and $V$ will detect this with probability $1/2$.

Now assume $k > 1$. At the first step of the protocol $P$ provides an intermediate configuration $C'$. Either there is no path between $C_1$ and $C'$ or there is no path between $C'$ and $C_N$. Say it is the former: the protocol will proceed on the left with probability $1/2$ and then $V$ will detect $P$ cheating with probability $2^{-k+1}$ by induction hypothesis, which concludes the proof.
\end{proof}

\medskip
\noindent
The theorem above implies directly the following results:

\begin{corollary}
$ \L \subseteq \NL \subseteq \DRMA[O(\log n), O(\log^2 n ), O(\log^2 n )]$
\end{corollary}


\begin{corollary}
$ \SC \subseteq  \NSC \subseteq \DRMA[O(\log n), O(\polylog(n)), O(\polylog(n))]$
\end{corollary}
